package com.tschuchort.compiletesting

import okio.Buffer
import org.jetbrains.kotlin.base.kapt3.KaptOptions
import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
import org.jetbrains.kotlin.cli.common.arguments.parseCommandLineArguments
import org.jetbrains.kotlin.cli.common.arguments.validateArguments
import org.jetbrains.kotlin.cli.common.messages.MessageRenderer
import org.jetbrains.kotlin.cli.common.messages.PrintingMessageCollector
import org.jetbrains.kotlin.cli.js.K2JSCompiler
import org.jetbrains.kotlin.cli.jvm.plugins.ServiceLoaderLite
import org.jetbrains.kotlin.compiler.plugin.CommandLineProcessor
import org.jetbrains.kotlin.compiler.plugin.ComponentRegistrar
import org.jetbrains.kotlin.config.Services
import java.io.*
import java.net.URI
import java.net.URLClassLoader
import java.nio.file.Files
import java.nio.file.Paths

@Suppress("MemberVisibilityCanBePrivate")
class KotlinJsCompilation {

  /** Working directory for the compilation */
  var workingDir: File by default {
    val path = Files.createTempDirectory("Kotlin-JS-Compilation")
    log("Created temporary working directory at ${path.toAbsolutePath()}")
    return@default path.toFile()
  }

  var outputFileName: String = "test.js"

  /**
   * Paths to directories or .jar files that contain classes
   * to be made available in the compilation (i.e. added to
   * the classpath)
   */
  var classpaths: List<File> = emptyList()

  /**
   * Paths to plugins to be made available in the compilation
   */
  var pluginClasspaths: List<File> = emptyList()

  /**
   * Compiler plugins that should be added to the compilation
   */
  var compilerPlugins: List<ComponentRegistrar> = emptyList()

  /**
   * Commandline processors for compiler plugins that should be added to the compilation
   */
  var commandLineProcessors: List<CommandLineProcessor> = emptyList()

  /** Source files to be compiled */
  var sources: List<SourceFile> = emptyList()

  /** Print verbose logging info */
  var verbose: Boolean = true

  /**
   * Helpful information (if [verbose] = true) and the compiler
   * system output will be written to this stream
   */
  var messageOutputStream: OutputStream = System.out

  /** Inherit classpath from calling process */
  var inheritClassPath: Boolean = false

  /** Suppress all warnings */
  var suppressWarnings: Boolean = false

  /** All warnings should be treated as errors */
  var allWarningsAsErrors: Boolean = false

  /** Report locations of files generated by the compiler */
  var reportOutputFiles: Boolean by default { verbose }

  /** Report on performance of the compilation */
  var reportPerformance: Boolean = false


  /**
   * Generate unpacked KLIB into parent directory of output JS file. In combination with -meta-info
   * generates both IR and pre-IR versions of library.
   */
  var irProduceKlibDir: Boolean = false

  /** Generate packed klib into file specified by -output. Disables pre-IR backend */
  var irProduceKlibFile: Boolean = false

  /** Generates JS file using IR backend. Also disables pre-IR backend */
  var irProduceJs: Boolean = false

  /** Perform experimental dead code elimination */
  var irDce: Boolean = false

  /** Perform a more experimental faster dead code elimination */
  var irDceDriven: Boolean = false

  /** Print declarations' reachability info to stdout during performing DCE */
  var irDcePrintReachabilityInfo: Boolean = false

  /** Disables pre-IR backend */
  var irOnly: Boolean = false

  /** Specify a compilation module name for IR backend */
  var irModuleName: String? = null


  /** Additional string arguments to the Kotlin compiler */
  var kotlincArguments: List<String> = emptyList()

  /** Options to be passed to compiler plugins: -P plugin:<pluginId>:<optionName>=<value>*/
  var pluginOptions: List<PluginOption> = emptyList()

  /**
   * Path to the kotlin-stdlib-common.jar
   * If none is given, it will be searched for in the host
   * process' classpaths
   */
  var kotlinStdLibCommonJar: File? by default {
    findInHostClasspath(hostClasspaths, "kotlin-stdlib-common.jar",
      kotlinDependencyRegex("kotlin-stdlib-common"))
  }

  /**
   * Path to the kotlin-stdlib-js.jar
   * If none is given, it will be searched for in the host
   * process' classpaths
   */
  var kotlinStdLibJsJar: File? by default {
    findInHostClasspath(hostClasspaths, "kotlin-stdlib-js.jar",
      kotlinDependencyRegex("kotlin-stdlib-js"))
  }

  // Directory for input source files
  private val sourcesDir get() = workingDir.resolve("sources")

  // *.class files, Jars and resources (non-temporary) that are created by the
  // compilation will land here
  val outputDir get() = workingDir.resolve("output")

  /** Result of the compilation */
  inner class Result(
    /** The exit code of the compilation */
    val exitCode: ExitCode,
    /** Messages that were printed by the compilation */
    val messages: String
  ) {
    /** class loader to load the compile classes */
    val classLoader = URLClassLoader(arrayOf(outputDirectory.toURI().toURL()),
      this::class.java.classLoader)

    /** The directory where only the final output class and resources files will be */
    val outputDirectory: File get() = outputDir

    /**
     * Compiled class and resource files that are the final result of the compilation.
     */
    val compiledClassAndResourceFiles: List<File> = outputDirectory.listFilesRecursively()
  }


  // setup common arguments for the two kotlinc calls
  private fun commonK2JSArgs() = K2JSCompilerArguments().also { args ->
    args.pluginClasspaths = pluginClasspaths.map(File::getAbsolutePath).toTypedArray()

    args.verbose = verbose

    // the compiler should never look for stdlib or reflect in the
    // kotlinHome directory (which is null anyway). We will put them
    // in the classpath manually if they're needed
    args.noStdlib = true

    args.sourceMap = true
    args.listPhases = true
    args.moduleKind = "commonjs"
    args.outputFile = File(outputDir, outputFileName).absolutePath
    args.metaInfo = true
    args.sourceMapBaseDirs = commonClasspaths().joinToString(separator = File.pathSeparator)
    args.libraries = listOfNotNull(kotlinStdLibJsJar).joinToString(separator = ":")

    args.irProduceKlibDir = irProduceKlibDir
    args.irProduceKlibFile = irProduceKlibFile
    args.irProduceJs = irProduceJs
    args.irDce = irDce
    args.irDceDriven = irDceDriven
    args.irDcePrintReachabilityInfo = irDcePrintReachabilityInfo
    args.irOnly = irOnly
    args.irModuleName = irModuleName

    args.multiPlatform = true
    args.reportOutputFiles = true

    args.suppressWarnings = suppressWarnings
    args.allWarningsAsErrors = allWarningsAsErrors
    args.reportOutputFiles = reportOutputFiles
    args.reportPerf = reportPerformance


    /**
     * It's not possible to pass dynamic [CommandLineProcessor] instances directly to the [K2JSCompiler]
     * because the compiler discovers them on the classpath through a service locator, so we need to apply
     * the same trick as with [ComponentRegistrar]s: We put our own static [CommandLineProcessor] on the
     * classpath which in turn calls the user's dynamic [CommandLineProcessor] instances.
     */
    MainCommandLineProcessor.threadLocalParameters.set(
      MainCommandLineProcessor.ThreadLocalParameters(commandLineProcessors)
    )

    /**
     * Our [MainCommandLineProcessor] only has access to the CLI options that belong to its own plugin ID.
     * So in order to be able to access CLI options that are meant for other [CommandLineProcessor]s we
     * wrap these CLI options, send them to our own plugin ID and later unwrap them again to forward them
     * to the correct [CommandLineProcessor].
     */
    args.pluginOptions = pluginOptions.map { (pluginId, optionName, optionValue) ->
      "plugin:${MainCommandLineProcessor.pluginId}:${MainCommandLineProcessor.encodeForeignOptionName(pluginId, optionName)}=$optionValue"
    }.toTypedArray()

    /* Parse extra CLI arguments that are given as strings so users can specify arguments that are not yet
    implemented here as well-typed properties. */
    parseCommandLineArguments(kotlincArguments, args)

    validateArguments(args.errors)?.let {
      throw IllegalArgumentException("Errors parsing kotlinc CLI arguments:\n$it")
    }
  }

  private fun getResourcesPath(): String {
    val resourceName = "META-INF/services/org.jetbrains.kotlin.compiler.plugin.ComponentRegistrar"
    return this::class.java.classLoader.getResources(resourceName)
      .asSequence()
      .mapNotNull { url ->
        val uri = URI.create(url.toString().removeSuffix("/$resourceName"))
        when (uri.scheme) {
          "jar" -> Paths.get(URI.create(uri.schemeSpecificPart.removeSuffix("!")))
          "file" -> Paths.get(uri)
          else -> return@mapNotNull null
        }.toAbsolutePath()
      }
      .find { resourcesPath ->
        ServiceLoaderLite.findImplementations(ComponentRegistrar::class.java, listOf(resourcesPath.toFile()))
          .any { implementation -> implementation == MainComponentRegistrar::class.java.name }
      }?.toString() ?: throw AssertionError("Could not get path to ComponentRegistrar service from META-INF")
  }

  /** Performs the compilation step to compile Kotlin source files */
  private fun compileKotlinJs(sources: List<File>): ExitCode {

    /**
     * Here the list of compiler plugins is set
     *
     * To avoid that the annotation processors are executed twice,
     * the list is set to empty
     */
    MainComponentRegistrar.threadLocalParameters.set(
      MainComponentRegistrar.ThreadLocalParameters(
        listOf(),
        KaptOptions.Builder(),
        compilerPlugins
      )
    )

    // if no Kotlin sources are available, skip the compileKotlin step
    if (sources.none(File::hasKotlinFileExtension))
      return ExitCode.OK

    // in this step also include source files generated by kapt in the previous step
    val args = commonK2JSArgs().also { args ->
      args.freeArgs = sources.map(File::getAbsolutePath).distinct()
      args.pluginClasspaths = (args.pluginClasspaths ?: emptyArray()) + arrayOf(getResourcesPath())
    }

    val compilerMessageCollector = PrintingMessageCollector(
      internalMessageStream, MessageRenderer.GRADLE_STYLE, verbose
    )

    return convertKotlinExitCode(K2JSCompiler().exec(compilerMessageCollector, Services.EMPTY, args))
  }

  /** Runs the compilation task */
  fun compile(): Result {
    // make sure all needed directories exist
    sourcesDir.mkdirs()
    outputDir.mkdirs()

    // write given sources to working directory
    val sourceFiles = sources.map { it.writeIfNeeded(sourcesDir) }

    pluginClasspaths.forEach { filepath ->
      if (!filepath.exists()) {
        error("Plugin $filepath not found")
        return makeResult(ExitCode.INTERNAL_ERROR)
      }
    }


    /* Work around for warning that sometimes happens:
    "Failed to initialize native filesystem for Windows
    java.lang.RuntimeException: Could not find installation home path.
    Please make sure bin/idea.properties is present in the installation directory"
    See: https://github.com/arturbosch/detekt/issues/630
    */
    withSystemProperty("idea.use.native.fs.for.win", "false") {
      // step 1: compile Kotlin files
      return makeResult(compileKotlinJs(sourceFiles))
    }
  }

  private fun makeResult(exitCode: ExitCode): Result {
    val messages = internalMessageBuffer.readUtf8()

    if (exitCode != ExitCode.OK)
      searchSystemOutForKnownErrors(messages)

    return Result(exitCode, messages)
  }

  private fun commonClasspaths() = mutableListOf<File>().apply {
    addAll(classpaths)
    addAll(listOfNotNull(kotlinStdLibCommonJar, kotlinStdLibJsJar))

    if (inheritClassPath) {
      addAll(hostClasspaths)
      log("Inheriting classpaths:  " + hostClasspaths.joinToString(File.pathSeparator))
    }
  }.distinct()

  /** Searches compiler log for known errors that are hard to debug for the user */
  private fun searchSystemOutForKnownErrors(compilerSystemOut: String) {
    if (compilerSystemOut.contains("No enum constant com.sun.tools.javac.main.Option.BOOT_CLASS_PATH")) {
      warn(
        "${this::class.simpleName} has detected that the compiler output contains an error message that may be " +
          "caused by including a tools.jar file together with a JDK of version 9 or later. " +
          if (inheritClassPath)
            "Make sure that no tools.jar (or unwanted JDK) is in the inherited classpath"
          else ""
      )
    }

    if (compilerSystemOut.contains("Unable to find package java.")) {
      warn(
        "${this::class.simpleName} has detected that the compiler output contains an error message " +
          "that may be caused by a missing JDK. This can happen if jdkHome=null and inheritClassPath=false."
      )
    }
  }

  /** Tries to find a file matching the given [regex] in the host process' classpath */
  private fun findInHostClasspath(hostClasspaths: List<File>, simpleName: String, regex: Regex): File? {
    val jarFile = hostClasspaths.firstOrNull { classpath ->
      classpath.name.matches(regex)
      //TODO("check that jar file actually contains the right classes")
    }

    if (jarFile == null)
      log("Searched host classpaths for $simpleName and found no match")
    else
      log("Searched host classpaths for $simpleName and found ${jarFile.path}")

    return jarFile
  }

  private val hostClasspaths by lazy { getHostClasspaths() }

  /* This internal buffer and stream is used so it can be easily converted to a string
  that is put into the [Result] object, in addition to printing immediately to the user's
  stream. */
  private val internalMessageBuffer = Buffer()
  private val internalMessageStream = PrintStream(
    TeeOutputStream(
      object : OutputStream() {
        override fun write(b: Int) = messageOutputStream.write(b)
        override fun write(b: ByteArray) = messageOutputStream.write(b)
        override fun write(b: ByteArray, off: Int, len: Int) = messageOutputStream.write(b, off, len)
        override fun flush() = messageOutputStream.flush()
        override fun close() = messageOutputStream.close()
      },
      internalMessageBuffer.outputStream()
    )
  )

  private fun log(s: String) {
    if (verbose)
      internalMessageStream.println("logging: $s")
  }

  private fun warn(s: String) = internalMessageStream.println("warning: $s")
  private fun error(s: String) = internalMessageStream.println("error: $s")
}
